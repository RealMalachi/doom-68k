// Emacs style mode select   -*- C++ -*- 
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// $Log:$
//
// DESCRIPTION:
//	DOOM main program (D_DoomMain) and game loop (D_DoomLoop),
//	plus functions to determine game mode (shareware, registered),
//	parse command line parameters, configure game parameters (turbo),
//	and call the startup functions.
//
//-----------------------------------------------------------------------------


static const char rcsid[] = "$Id: d_main.c,v 1.8 1997/02/03 22:45:09 b1 Exp $";

#define	BGCOLOR		7
#define	FGCOLOR		8


#include "doomdef.h"
#include "doomstat.h"

#include "dstrings.h"
#include "sounds.h"


#include "z_zone.h"
#include "w_wad.h"
#include "s_sound.h"
#include "v_video.h"

#include "f_finale.h"
#include "f_wipe.h"

#include "m_argv.h"
#include "m_misc.h"
#include "m_menu.h"

#include "i_system.h"
#include "i_sound.h"
#include "i_video.h"

#include "g_game.h"

#include "hu_stuff.h"
#include "wi_stuff.h"
#include "st_stuff.h"
#include "am_map.h"

#include "p_setup.h"
#include "r_local.h"


#include "d_main.h"

#include "my_unistd.h"
#include "bios.h"



//
// D-DoomLoop()
// Not a globally visible function,
//  just included for source reference,
//  called by D_DoomMain, never exits.
// Manages timing and IO,
//  calls all ?_Responder, ?_Ticker, and ?_Drawer,
//  calls I_GetTime, I_StartFrame, and I_StartTic
//
void D_DoomLoop(void);


char* wadfiles[MAXWADFILES];


doomboolean devparm; // started game with -devparm
doomboolean nomonsters; // checkparm of -nomonsters
doomboolean respawnparm; // checkparm of -respawn
doomboolean fastparm; // checkparm of -fast

doomboolean drone;

doomboolean singletics = false; // debug flag to cancel adaptiveness



//extern int soundVolume;
//extern  int	sfxVolume;
//extern  int	musicVolume;

extern doomboolean inhelpscreens;

skill_t startskill;
int startepisode;
int startmap;
doomboolean autostart;

FILE* debugfile;

doomboolean advancedemo;




char wadfile[1024]; // primary wad file
char mapdir[1024]; // directory of development maps
char basedefault[1024]; // default file


void D_CheckNetGame(void);
void D_ProcessEvents(void);
void G_BuildTiccmd(ticcmd_t* cmd);
void D_DoAdvanceDemo(void);


//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//
event_t events[MAXEVENTS];
int eventhead;
int eventtail;


//
// D_PostEvent
// Called by the I/O functions when input is detected
//

void D_PostEvent(event_t* ev) {

    events[eventhead] = *ev;
    eventhead++;
    eventhead = (eventhead)&(MAXEVENTS - 1);
}


//
// D_ProcessEvents
// Send all the events of the given timestamp down the responder chain
//

void D_ProcessEvents(void) {
    event_t* ev;

    // IF STORE DEMO, DO NOT ACCEPT INPUT
    if ((gamemode == commercial)
            && (W_CheckNumForName("map01") < 0))
        return;

    for (; eventtail != eventhead; eventtail = (++eventtail)&(MAXEVENTS - 1)) {

        ev = &events[eventtail];
        if (M_Responder(ev)) continue; // menu ate the event

        G_Responder(ev);
    }
}




//
// D_Display
//  draw current display, possibly wiping it from the previous
//

// wipegamestate can be set to -1 to force a wipe on the next draw
gamestate_t wipegamestate = GS_DEMOSCREEN;
extern doomboolean setsizeneeded;
extern int showMessages;
void R_ExecuteSetViewSize(void);

void D_Display(void) {

    doomboolean viewactivestate = false;
    doomboolean menuactivestate = false;
    doomboolean inhelpscreensstate = false;
    doomboolean fullscreen = false;
    gamestate_t oldgamestate = -1;
    int borderdrawcount;
    int y;


    if (nodrawers)return; // for comparative timing / profiling


    // change the view size if needed
    if (setsizeneeded) {
        R_ExecuteSetViewSize();
        oldgamestate = -1; // force background redraw
        borderdrawcount = 3;
    }


    // do buffered drawing
    switch (gamestate) {

        case GS_LEVEL:
            if (!gametic)break;
            fullscreen = viewheight == 200;
            break;

        case GS_INTERMISSION:
            WI_Drawer();
            break;

        case GS_FINALE:
            F_Drawer();
            break;

        case GS_DEMOSCREEN:
            D_PageDrawer();
            break;
    }


    // draw the view directly
    if (gamestate == GS_LEVEL && !automapactive && gametic) {
        R_RenderPlayerView(&players[displayplayer]);
    }


    if (gamestate == GS_LEVEL && gametic) {
        HU_Drawer();
    }

    // clean up border stuff
    if (gamestate != oldgamestate && gamestate != GS_LEVEL) {
        I_SetPalette(W_CacheLumpName("PLAYPAL", PU_CACHE));
    }


    menuactivestate = menuactive;
    viewactivestate = viewactive;
    inhelpscreensstate = inhelpscreens;
    oldgamestate = wipegamestate = gamestate;

    // draw pause pic
    if (paused) {

        y = automapactive ? 4 : viewwindowy + 4;
        V_DrawPatchDirect(viewwindowx + (scaledviewwidth - 68) / 2,
                y, 0, W_CacheLumpName("M_PAUSE", PU_CACHE));
    }


    // menus go directly to the screen
    M_Drawer(); // menu is drawn even on top of everything


}



//
//  D_DoomLoop
//

void D_DoomLoop(void) {

    /*
        if (singletics) {

            I_StartTic();
            D_ProcessEvents();
            G_BuildTiccmd(&netcmds[consoleplayer][maketic % BACKUPTICS]);
            if (advancedemo) {
                D_DoAdvanceDemo();
            }
            M_Ticker();
            G_Ticker();
            gametic++;
            maketic++;

        } else {
            TryRunTics(); // will run at least one tic
        }*/

    //TryRunTics(); // will run at least one tic


    u16 i;
    D_ProcessEvents();
    G_BuildTiccmd(&netcmds[consoleplayer][maketic % BACKUPTICS]);

    u16 t1;
    t1 = bi_get_ticks();

    for (i = 0; i < 5; i++) {

        if (advancedemo) {
            D_DoAdvanceDemo();
        }

        //M_Ticker();
        G_Ticker();
        gametic++;
        maketic++;
    }

    t1 = bi_get_ticks() - t1;
    std_printf("ltme: %d    \n", t1);
    //S_UpdateSounds(players[consoleplayer].mo);
    D_Display();


    //I_SubmitSound();

}


//
//  DEMO LOOP
//
int demosequence;
int pagetic;
char *pagename;


//
// D_PageTicker
// Handles timing for warped projection
//

void D_PageTicker(void) {
    if (--pagetic < 0)
        D_AdvanceDemo();
}



//
// D_PageDrawer
//

void D_PageDrawer(void) {
    V_DrawPatch(0, 0, 0, W_CacheLumpName(pagename, PU_CACHE));
}


//
// D_AdvanceDemo
// Called after each demo or intro demosequence finishes
//

void D_AdvanceDemo(void) {
    advancedemo = true;
}


//
// This cycles through the demo sequences.
// FIXME - version dependend demo numbers?
//

void D_DoAdvanceDemo(void) {
    players[consoleplayer].playerstate = PST_LIVE; // not reborn
    advancedemo = false;
    usergame = false; // no save / end game here
    paused = false;
    gameaction = ga_nothing;

    if (gamemode == retail)
        demosequence = (demosequence + 1) % 7;
    else
        demosequence = (demosequence + 1) % 6;

    switch (demosequence) {
        case 0:
            if (gamemode == commercial)
                pagetic = 35 * 11;
            else
                pagetic = 170;
            gamestate = GS_DEMOSCREEN;
            pagename = "TITLEPIC";
            if (gamemode == commercial)
                S_StartMusic(mus_dm2ttl);
            else
                S_StartMusic(mus_intro);
            break;
        case 1:
            G_DeferedPlayDemo("demo1");
            break;
        case 2:
            pagetic = 200;
            gamestate = GS_DEMOSCREEN;
            pagename = "CREDIT";
            break;
        case 3:
            G_DeferedPlayDemo("demo2");
            break;
        case 4:
            gamestate = GS_DEMOSCREEN;
            if (gamemode == commercial) {
                pagetic = 35 * 11;
                pagename = "TITLEPIC";
                S_StartMusic(mus_dm2ttl);
            } else {
                pagetic = 200;

                if (gamemode == retail)
                    pagename = "CREDIT";
                else
                    pagename = "HELP2";
            }
            break;
        case 5:
            G_DeferedPlayDemo("demo3");
            break;
            // THE DEFINITIVE DOOM Special Edition demo
        case 6:
            G_DeferedPlayDemo("demo4");
            break;
    }
}



//
// D_StartTitle
//

void D_StartTitle(void) {
    gameaction = ga_nothing;
    demosequence = -1;
    D_AdvanceDemo();
}




//      print title for every printed line
char title[128];



//
// D_AddFile
//

void D_AddFile(char *file) {

    int numwadfiles;
    char *newfile;

    for (numwadfiles = 0; wadfiles[numwadfiles]; numwadfiles++);

    newfile = std_malloc(std_strlen(file) + 1);
    std_strcpy(newfile, file);

    wadfiles[numwadfiles] = newfile;
}

//
// IdentifyVersion
// Checks availability of IWAD files by name,
// to determine whether registered/commercial features
// should be executed (notably loading PWAD's).
//

void IdentifyVersion(void) {

    char* doom1wad;
    char* doomwad;
    char* doomuwad;
    char* doom2wad;

    char* doom2fwad;
    char* plutoniawad;
    char* tntwad;

    char *doomwaddir = ".";

    /*
    u16 i;
    for (i = 0; i < MAXWADFILES; i++) {
        wadfiles[i] = 0;//memory fix
    }*/

    /*
    doomwaddir = getenv("DOOMWADDIR");
    if (!doomwaddir)
        doomwaddir = ".";*/

    // Commercial.
    doom2wad = std_malloc(std_strlen(doomwaddir) + 1 + 9 + 1);
    std_sprintf(doom2wad, "%s/doom2.wad", doomwaddir);

    // Retail.
    doomuwad = std_malloc(std_strlen(doomwaddir) + 1 + 8 + 1);
    std_sprintf(doomuwad, "%s/doomu.wad", doomwaddir);

    // Registered.
    doomwad = std_malloc(std_strlen(doomwaddir) + 1 + 8 + 1);
    std_sprintf(doomwad, "%s/doom.wad", doomwaddir);

    // Shareware.
    doom1wad = std_malloc(std_strlen(doomwaddir) + 1 + 9 + 1);
    std_sprintf(doom1wad, "%s/doom1.wad", doomwaddir);

    // Bug, dear Shawn.
    // Insufficient malloc, caused spurious realloc errors.
    plutoniawad = std_malloc(std_strlen(doomwaddir) + 1 + /*9*/12 + 1);
    std_sprintf(plutoniawad, "%s/plutonia.wad", doomwaddir);

    tntwad = std_malloc(std_strlen(doomwaddir) + 1 + 9 + 1);
    std_sprintf(tntwad, "%s/tnt.wad", doomwaddir);


    // French stuff.
    doom2fwad = std_malloc(std_strlen(doomwaddir) + 1 + 10 + 1);
    std_sprintf(doom2fwad, "%s/doom2f.wad", doomwaddir);
    /*
        home = getenv("HOME");
        if (!home)
          I_Error("Please set $HOME to your home directory");
        sprintf(basedefault, "%s/.doomrc", home);
     */
    std_sprintf(basedefault, "%s", ".");

    if (M_CheckParm("-shdev")) {
        gamemode = shareware;
        devparm = true;
        D_AddFile(DEVDATA"doom1.wad");
        D_AddFile(DEVMAPS"data_se/texture1.lmp");
        D_AddFile(DEVMAPS"data_se/pnames.lmp");
        std_strcpy(basedefault, DEVDATA"default.cfg");
        return;
    }

    if (M_CheckParm("-regdev")) {
        gamemode = registered;
        devparm = true;
        D_AddFile(DEVDATA"doom.wad");
        D_AddFile(DEVMAPS"data_se/texture1.lmp");
        D_AddFile(DEVMAPS"data_se/texture2.lmp");
        D_AddFile(DEVMAPS"data_se/pnames.lmp");
        std_strcpy(basedefault, DEVDATA"default.cfg");
        return;
    }

    if (M_CheckParm("-comdev")) {
        gamemode = commercial;
        devparm = true;
        /* I don't bother
        if(plutonia)
            D_AddFile (DEVDATA"plutonia.wad");
        else if(tnt)
            D_AddFile (DEVDATA"tnt.wad");
        else*/
        D_AddFile(DEVDATA"doom2.wad");

        D_AddFile(DEVMAPS"cdata/texture1.lmp");
        D_AddFile(DEVMAPS"cdata/pnames.lmp");
        std_strcpy(basedefault, DEVDATA"default.cfg");
        return;
    }
    /*
        if (!sys_access(doom2fwad, R_OK)) {
            gamemode = commercial;
            // C'est ridicule!
            // Let's handle languages in config files, okay?
            language = french;
            sys_printf("French version\n");
            D_AddFile(doom2fwad);
            return;
        }*/

    if (!std_access(doom2wad, R_OK)) {
        gamemode = commercial;
        D_AddFile(doom2wad);
        return;
    }

    if (!std_access(plutoniawad, R_OK)) {
        gamemode = commercial;
        D_AddFile(plutoniawad);
        return;
    }

    if (!std_access(tntwad, R_OK)) {
        gamemode = commercial;
        D_AddFile(tntwad);
        return;
    }

    if (!std_access(doomuwad, R_OK)) {
        gamemode = retail;
        D_AddFile(doomuwad);
        return;
    }

    if (!std_access(doomwad, R_OK)) {
        gamemode = registered;
        D_AddFile(doomwad);
        return;
    }

    if (!std_access(doom1wad, R_OK)) {
        gamemode = shareware;
        D_AddFile(doom1wad);
        return;
    }

    std_printf("Game mode indeterminate.\n");
    gamemode = indetermined;
}

//
// D_DoomMain
//
extern doomboolean demorecording;

void D_DoomInit(void) {

    //int p;
    //char file[256];

    //FindResponseFile();

    IdentifyVersion();

    //setbuf(stdout, NULL);
    modifiedgame = false;


    switch (gamemode) {
        case retail:
            std_sprintf(title,
                    "The Ultimate DOOM Startup v%i.%i",
                    VERSION / 100, VERSION % 100);
            break;
        case shareware:
            std_sprintf(title,
                    "DOOM Shareware Startup v%i.%i",
                    VERSION / 100, VERSION % 100);
            break;
        case registered:
            std_sprintf(title,
                    "DOOM Registered Startup v%i.%i",
                    VERSION / 100, VERSION % 100);
            break;
        case commercial:
            std_sprintf(title,
                    "DOOM 2: Hell on Earth v%i.%i",
                    VERSION / 100, VERSION % 100);
            break;
        default:
            std_sprintf(title,
                    "Public DOOM - v%i.%i",
                    VERSION / 100, VERSION % 100);
            break;
    }

    std_printf("%s\n", title);


    // get skill / episode / map from parms
    startskill = sk_medium;
    startepisode = 1;
    startmap = 1;
    autostart = false;


    // init subsystems
    std_printf("V_Init: allocate screens.\n");
    V_Init();

    std_printf("M_LoadDefaults: Load system defaults.\n");
    M_LoadDefaults(); // load before initing other systems

    std_printf("Z_Init: Init zone memory allocation daemon. \n");
    Z_Init();

    std_printf("W_Init: Init WADfiles.\n");
    W_InitMultipleFiles(wadfiles);



    std_printf("M_Init: Init miscellaneous info.\n");
    M_Init();

    std_printf("R_Init: Init DOOM refresh daemon.");
    R_Init();

    std_printf("\nP_Init: Init Playloop state.\n");
    P_Init();

    //sys_printf("I_Init: Setting up machine state.\n");
    //I_Init();

    std_printf("D_CheckNetGame: Checking network game status.\n");
    D_CheckNetGame();

    std_printf("S_Init: Setting up sound.\n");
    S_Init(snd_SfxVolume /* *8 */, snd_MusicVolume /* *8*/);

    std_printf("HU_Init: Setting up heads up display.\n");
    HU_Init();

    std_printf("ST_Init: Init status bar.\n");
    ST_Init();


    if (gameaction != ga_loadgame) {
        if (autostart || netgame)
            G_InitNew(startskill, startepisode, startmap);
        else
            D_StartTitle(); // start up intro loop

    }



    if (demorecording) {
        G_BeginRecording();
    }

    /*
    if (M_CheckParm("-debugfile")) {
        char filename[20];
        sys_sprintf(filename, "debug%i.txt", consoleplayer);
        sys_printf("debug output to: %s\n", filename);
        debugfile = fopen(filename, "w");
    }*/

    I_InitGraphics();
    //D_DoomLoop(); // never returns
}
